/** JavaScript의 "this"
 * 함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 둘을 구분하는 유일한 기능.
 * 
 * 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정
 * == 함수를 호출할 때 결정된다.
 * 
 * this가 가리키는 것
 * 전역공간 - 전역 객체 (브라우저:window, Node.js:global)
 * 
 * 함수를 어떤 객체의 메서드로서 호출할 경우에만 메서드로 동작한다.
 * 
 *  == 
 * 점 표기법이든 대괄호 표기법이든, 
 * 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것, 
 * 그렇지 않은 모든 경우는 함수로 호출한 것.
 * 
 * JavaScript는 함수에 생성자로서의 역할을 함께 부여했다. (ch3-p13.js)
 * new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다.
 *  + 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.
 *  : 생성자 함수 호출(new 명령어) 
 *      -> 생성자의 prototype 프로퍼티를 참조하는 __proto__(프로퍼티)가 있는 객체(인스턴스 생성)
 *      -> 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여
 * 
 * ==02==
 * 명시적으로 this를 바인딩 하는 방법
 * Function.prototype.call(thisArg[, arg1[, arg2[,...]]])
 * call 메서드 : 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령.
 *              call 메서드는 첫번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다.
 *              (함수를 그냥 실행 => this는 전역객체 , call 메서드를 이용 => 임의의 객체를 this로 지정.)
 * (ch3-p14.js)
 * 
 * Function.prototype.apply(thisArg[, argsArray])
 * apply 메서드 : call 메서드와 기능적으로 완전히 동일.
 *              apply에서는 두번째 인자를 배열로 받아 배열의 요소들을 호출할 함수의 매개변수로 지정하는 차이.
 * 
 * call/apply 활용 - 유사 배열 객체(array-like object)
 *                  L 키가 0 또는 양의 정수인 프로퍼티가 존재하고, length 프로퍼티 값이 0 또는 양의 정수인 객체.
 *                      (배열 구조와 유사함)
 * 
 * 
 * 
 */